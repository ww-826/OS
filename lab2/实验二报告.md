# lab2报告

## 重要知识点对应关系

### 1. 物理内存与虚拟地址空间

**OS原理知识点**：

- 物理内存是实际的硬件存储单元，通过物理地址直接访问
- 虚拟地址空间为每个进程提供独立的地址空间，实现内存隔离

**实验对应**：

- 物理地址直接映射：`0x80200000`
- 虚拟地址空间：`0xffffffffc0200000` 开始的高地址空间
- 通过页表机制实现虚实地址转换

**理解**：实验通过引入页表机制，将内核从直接使用物理地址转变为使用虚拟地址空间，实现了OS原理中的地址空间隔离概念。差异在于实验具体实现了RISCV架构下的sv39页表机制。

### 2. 分页机制与多级页表

**OS原理知识点**：

- 分页将内存划分为固定大小的页
- 多级页表解决单级页表空间开销大的问题

**实验对应**：

- 使用sv39三级页表结构
- 页大小4KB，支持2MB大页和1GB大大页
- 页表项64位结构，包含权限位和物理页号

**理解**：实验具体实现了三级页表的结构设计，体现了OS原理中多级页表节省空间的优势。实验更详细地展示了页表项的具体位域定义和权限控制机制。

### 3. 物理内存管理

**OS原理知识点**：

- 连续内存分配
- 页帧管理
- 内存分配算法

**实验对应**：

- `struct Page` 结构体管理物理页帧
- `pmm_manager` 接口抽象物理内存管理
- 实现First Fit分配算法

**理解**：实验通过`pmm_manager`结构体实现了面向接口的编程，将OS原理中的物理内存管理概念具体化为可执行的代码。差异在于实验提供了可扩展的框架，支持不同的分配算法实现。

### 4. 地址转换机制

**OS原理知识点**：

- 虚拟地址到物理地址的转换
- TLB加速地址转换

**实验对应**：

- `satp`寄存器设置页表基址
- `sfence.vma`指令刷新TLB
- 固定偏移量映射：`va - 0xffffffff40000000 = pa`

**理解**：实验详细展示了RISCV架构下地址转换的硬件支持机制，将OS原理中的MMU概念具体化为寄存器操作和指令使用。

### 5. 内存探测与初始化

**OS原理知识点**：

- 系统启动时探测可用物理内存
- 初始化内存管理数据结构

**实验对应**：

- 通过DTB(Device Tree Blob)获取物理内存信息
- `page_init()`函数初始化页面管理结构
- 区分已用内存和可用内存区域

**理解**：实验展示了在真实系统中如何获取物理内存布局信息，这是OS原理中较少涉及的实践细节。

## OS原理重要但实验中未对应的知识点

### 1. 页面置换算法

- 原理中的LRU、FIFO、Clock等页面置换算法
- 实验仅涉及物理内存分配，未涉及虚拟内存的页面置换

### 2. 内存映射文件

- 原理中将文件映射到进程地址空间的概念
- 实验仅涉及物理内存管理，未涉及文件映射

### 3. 共享内存

- 原理中进程间通过共享内存通信的机制
- 实验专注于内核内存管理，未涉及进程间共享

### 4. 内存压缩与去重

- 原理中的内存优化技术
- 实验专注于基础内存管理功能

### 5. NUMA架构内存管理

- 原理中的非统一内存访问架构优化
- 实验基于简单的UMA架构假设

### 6. 内存安全保护机制

- 原理中的ASLR、栈保护等安全机制
- 实验主要关注功能实现而非安全方面



# 练习1：理解 First-Fit 连续物理内存分配算法

First-Fit 连续物理内存分配算法是物理内存分配的基础方法。为深入理解其实现，我们结合实验手册与 `kern/mm/default_pmm.c` 中的代码，分析了 `default_init`、`default_init_memmap`、`default_alloc_pages` 和 `default_free_pages` 等关键函数，并梳理了物理内存分配的整体流程及其各自作用。

**算法实现概述**

该实现通过全局的 `free_area_t` 结构管理所有空闲物理内存，该结构包含两个成员：

- `free_list`：一个双向链表，用于连接所有空闲内存块
- `nr_free`：记录当前系统中所有空闲页的总数

空闲内存块的管理采用以下方式：

- 每个连续的空闲块由一组连续的 `struct Page` 结构表示
- 仅该空闲块的首页（`base`）会被加入 `free_list` 链表
- 首页的 `base->property` 字段记录该空闲块包含的页数
- 首页的 `base->flags` 会设置 `PG_property` 标志，表明其为空闲块的头页
- `free_list` 链表始终保持按物理地址从小到大的顺序排列

---

### 各函数功能详解

#### 1. `default_init`

- **功能**：初始化物理内存管理器
- **流程**：
  - 调用 `list_init(&free_list)` 初始化 `free_list` 为空链表
  - 将 `nr_free` 设置为 0，表示初始状态下没有空闲页

#### 2. `default_init_memmap`

- **功能**：将一段已知可用的物理内存区域（起始页 `base`，共 `n` 页）纳入空闲内存管理
- **流程**：
  1. **初始化页面属性**：遍历从 `base` 开始的 `n` 个页面，清除各页的 `flags` 与 `property`，并将 `ref` 置 0
  2. **设置头页**：设置 `base` 页的 `property = n`，并调用 `SetPageProperty(base)` 标记其为空闲块头页
  3. **更新空闲页计数**：执行 `nr_free += n`
  4. **按地址顺序插入链表**：
     - 若 `free_list` 为空，直接插入
     - 否则遍历链表，找到第一个物理地址大于 `base` 的页面，将 `base` 插入其前方；若无更大地址，则插入链表末尾。此操作确保链表始终按地址有序

#### 3. `default_alloc_pages`

- **功能**：分配 `n` 个连续的物理页，体现 **First-Fit 算法**核心
- **流程**：
  1. **检查可用性**：若 `n > nr_free`，直接返回 `NULL`
  2. **首次适配查找**：
     - 从 `free_list` 头部开始顺序遍历
     - 对每个空闲块的头页 `p`，检查其 `p->property`（块大小）是否 ≥ `n`
     - 一旦找到第一个满足条件的块 `page`，立即停止搜索
  3. **分配与拆分**：
     - 若未找到合适块，返回 `NULL`
     - 若找到：
       - **拆分大块**：若 `page->property > n`，则将剩余部分（`page + n` 起始）设为新空闲块，设置其 `property` 与 `PG_property` 标志，并插入 `free_list` 中原 `page` 的位置之前
       - **移除已分配块**：将 `page` 从 `free_list` 中移除
       - **更新计数**：执行 `nr_free -= n`
       - **更新页面标志**：调用 `ClearPageProperty(page)`，标记该页已被分配
       - **返回地址**：返回 `page` 的地址

#### 4. `default_free_pages`

- **功能**：释放从 `base` 开始的 `n` 个连续物理页，并尝试合并相邻空闲块
- **流程**：
  1. **初始化释放页**：遍历这 `n` 个页面，重置其 `flags` 和 `ref`
  2. **设置新头页**：设置 `base->property = n` 并调用 `SetPageProperty(base)` 标记为空闲块头页
  3. **更新计数**：执行 `nr_free += n`
  4. **有序插入链表**：与 `default_init_memmap` 类似，将 `base` 按地址顺序插入 `free_list`
  5. **合并相邻块**：
     - **向前合并**：检查 `base` 的前一个空闲块是否与其物理相邻，若相邻则合并，更新 `base` 指向合并后的块
     - **向后合并**：检查 `base` 的后一个空闲块是否与其物理相邻，若相邻则合并

**算法改进空间**

当前的 First-Fit 实现在以下方面有改进空间：

1. 查找效率：线性扫描链表在大量小碎片情况下性能较低，可考虑使用更高效的数据结构
2. 碎片问题：频繁分配释放可能产生外部碎片，可引入定期碎片整理机制

# 练习2：实现 Best-Fit 连续物理内存分配算法

本练习在 First-Fit 算法的基础上，实现了 Best-Fit（最佳适应）连续物理内存分配算法。其核心数据结构与 First-Fit 保持一致，仍然使用一个按物理地址升序排列的 `free_list` 来管理空闲内存块。两者的主要区别体现在分配策略上。

### 设计实现过程

Best-Fit 算法的设计目标是**最大限度地保留大的空闲块**，以满足未来的大内存请求。为实现这一目标，其分配逻辑与 First-Fit 有显著不同：

- **分配策略**：当请求分配 `n` 页内存时，Best-Fit 算法会**遍历整个** `free_list`，而不是找到第一个满足条件的块就停止。它会找出所有大小不小于 `n` 的空闲块中，尺寸**最小**的那一个。
- **数据结构**：实现上与 First-Fit 共享相同的数据结构，即一个 `free_area_t` 结构，包含一个按地址排序的 `free_list` 链表和记录总空闲页数的 `nr_free`。
- **释放与合并**：内存释放与合并的逻辑与 First-Fit **完全相同**，都依赖于地址有序的链表来高效地检查并合并相邻的空闲块。

### 内存分配与释放详解

#### 1. 物理内存的分配 (`best_fit_alloc_pages`)

这是体现 Best-Fit 思想的核心函数。

- **流程**：
  1. **完整遍历**：从 `free_list` 头部开始，完整地遍历每一个空闲块。
  2. **寻找最优块**：在遍历过程中，使用一个变量（如 `min_size`）记录当前已找到的、满足 `property >= n` 条件的块的最小尺寸，并用一个指针（如 `best_le`）记录该最优块的位置。
  3. **选择与分配**：遍历结束后，`best_le` 指向的就是最适合的空闲块。
  4. **拆分与更新**：从 `best_le` 指向的块中分配所需内存。如果块有剩余，则将剩余部分作为一个新的空闲块重新插入链表。此过程与 First-Fit 中的拆分逻辑一致。

- **与 First-Fit 的对比**：First-Fit 找到第一个满足条件的块就立即返回，而 Best-Fit 总是为了寻找“最佳”选择而付出遍历整个链表的代价。

#### 2. 物理内存的释放 (`best_fit_free_pages`)

释放和合并的逻辑与 First-Fit 完全一致，因为它们都依赖于一个按地址排序的 `free_list`。

- **流程**：
  1. **有序插入**：将待释放的内存块 `base` 按照其物理地址插入到 `free_list` 的正确位置，保持链表的地址有序性。
  2. **向前合并**：检查 `base` 在链表中的前一个节点，判断其物理地址是否与 `base` 连续。如果是，则将两者合并。
  3. **向后合并**：检查 `base`（可能是已合并过的新块）在链表中的后一个节点，判断其物理地址是否连续。如果是，则再次合并。

### Best-Fit 算法的改进空间

尽管 Best-Fit 算法在某些场景下能更好地保留大块内存，但它也存在明显的缺点和改进空间：

1.  **分配效率低下**：最大的问题在于 `best_fit_alloc_pages` 函数。每次分配都必须遍历整个空闲链表，导致其时间复杂度为 **O(N)**，其中 N 是空闲块的数量。在系统中存在大量碎片时，这会严重影响分配性能，远不如 First-Fit 的平均情况。
2.  **产生微小碎片**：Best-Fit 倾向于精确匹配，这会导致大的空闲块被分割后，常常留下了许多尺寸非常小、难以再次利用的碎片。虽然它努力保留了“大块”，但也制造了更多“废料”。
3.  **数据结构优化**：
    - **多重链表 (Segregated Fit)**：可以不使用单一链表，而是维护多个链表，每个链表负责一个特定尺寸范围的空闲块（例如，一个链表管理 1-4 页的块，另一个管理 5-16 页的块等）。分配时，只需在对应尺寸范围的链表中查找即可，能显著提高查找效率。
    - **树形结构**：可以使用更高级的数据结构，如红黑树来管理空闲块。以块大小为键进行排序，这样查找时间复杂度可以优化到 **O(log N)**。

### 实验结果

```
>make qemu

	......

(THU.CST) os is loading ...
Special kernel symbols:
  entry  0xffffffffc02000d6 (virtual)
  etext  0xffffffffc020164e (virtual)
  edata  0xffffffffc0205018 (virtual)
  end    0xffffffffc0205078 (virtual)
Kernel executable memory footprint: 20KB
memory management: best_fit_pmm_manager
physcial memory map:
  memory: 0x0000000008000000, [0x0000000080000000, 0x0000000087ffffff].
check_alloc_page() succeeded!
satp virtual address: 0xffffffffc0204000
satp physical address: 0x0000000080204000

>make grade

	......

<<<<<<<<<<<<<<< here_run_check <<<<<<<<<<<<<<<<<<
  -check physical_memory_map_information:    OK
  -check_best_fit:                           OK
Total Score: 25/25
```

# 扩展练习 Challenge：Buddy System（伙伴系统）分配算法

说明文档存放在`/mm/buddy_system_doc.md`

Buddy System 算法将可用存储空间划分为大小为 2 的 n 次幂的存储块进行管理，即 1, 2, 4, 8... 等大小的块。

### 1. 概述

伙伴系统的核心思想是将所有空闲内存划分为大小为 2 的幂次方（`2^k`）的块。分配内存时，寻找大小最接近且不小于请求大小的空闲块。如果找到的块过大，则递归对半分裂，直到得到合适大小的块，剩余的"伙伴"块放入相应大小的空闲链表中。释放内存时，检查伙伴块是否空闲，如果是则合并成更大块，并递归向上合并。

**主要特性：**

- **高效块操作**：通过位运算快速定位伙伴块，分裂和合并操作高效
- **减少外部碎片**：有效合并小块，减少外部碎片
- **内部碎片**：由于分配块大小向上取整到 2 的幂次方，可能产生内部碎片

### 2. 核心数据结构

对 `struct Page` 结构复用现有字段：

- `page_link`：将空闲块首页串联到对应大小的空闲链表中
- `property`：空闲块首页存储块的大小等级（order）；已分配块首页同样存储 order
- `flags`：通过 `PG_property` 标志位区分是否为空闲块首页

修改 `free_area_t` 逻辑，为每个大小的空闲块分别管理：

```c
#define MAX_ORDER 14

typedef struct {
    list_entry_t free_list; // 双向循环链表，链接该 order 的所有空闲块
    unsigned int nr_free;   // 该 order 的空闲块数量
} free_area_t;

static free_area_t free_area[MAX_ORDER + 1];
```

### 3. 算法实现

#### 3.1 `buddy_system_init_memmap` - 初始化与自然对齐

**核心原则：自然对齐**
大小为 `2^k` 页的块，其起始页索引必须是 `2^k` 的整数倍。

**实现逻辑：**

1. 将所有页面标记为非保留状态
2. 从内存区域起始位置开始循环处理
3. 在当前位置，从 `MAX_ORDER` 向下遍历，寻找能创建的**最大、满足自然对齐**的块
4. 设置块首页属性并加入对应空闲链表
5. 更新当前位置，继续处理剩余内存

#### 3.2 `buddy_system_alloc_pages` - 分配与分裂

1. **输入验证**：检查请求页数是否为 2 的幂次方
2. **寻找合适块**：计算请求对应的 `order`，从该 `order` 开始向上遍历寻找可用块
3. **分裂过程**：
   - 如果找到的块 `current_order` 大于请求的 `order`，进行分裂
   - 从链表中取出块，循环对半分裂：`current_order` 减一，计算伙伴块地址
   - 将伙伴块标记为新大小的空闲块，加入对应链表
   - 重复直到块大小等于请求的 `order`
4. **返回页面**：清除最终块的 `PG_property` 标志，更新总空闲页数

#### 3.3 `buddy_system_free_pages` - 释放与合并

1. **获取块信息**：根据待释放页 `base` 的 `property` 字段获取其 `order`
2. **合并循环**：
   - 循环尝试将当前块与其伙伴合并
   - 调用 `get_buddy_addr()` 计算伙伴块地址
   - **对伙伴块进行严格审查**：
     - 有效性：检查伙伴地址是否越界
     - 空闲状态：检查伙伴页的 `PG_property` 标志位
     - 大小匹配：检查伙伴页的 `order` 是否匹配
   - **执行合并**：如果审查通过，将伙伴从空闲链表移除，选择地址较小的作为新合并块首页，`order` 加一
   - **继续循环**：以新合并的块为基础继续尝试向上合并
3. **加入链表**：将最终块加入对应 `order` 的空闲链表

### 4. 测试策略 (`buddy_system_check`)

1. **初始状态打印**：显示系统初始内存分布
2. **基本分配/释放测试**：分配不同大小块后全部释放，验证空闲页数恢复
3. **边界与非法请求测试**：测试异常情况处理
4. **分裂与合并深度测试**：
   - 创建纯净环境：将碎片的小筷分配，避免干扰
   - 准备测试块：分配并释放中等大小块
   - 测试分裂：从大块中分配小块，验证地址正确性
   - 测试合并：依次释放小块，验证合并回原块
   - 恢复环境：释放初始分配的小块，确保总空闲页数一致



### 实验结果

```
>make qemu

	......

(THU.CST) os is loading ...
Special kernel symbols:
  entry  0xffffffffc02000d6 (virtual)
  etext  0xffffffffc020176c (virtual)
  edata  0xffffffffc0206018 (virtual)
  end    0xffffffffc02061d0 (virtual)
Kernel executable memory footprint: 25KB
memory management: buddy_system_pmm_manager
physcial memory map:
  memory: 0x0000000008000000, [0x0000000080000000, 0x0000000087ffffff].
==================================================
buddy_system_check() starting...
==================================================
Initial available page index range: [839, 32767]
  [Buddy Status] nr_free per order:
    order--0: 1
    order--3: 1
    order--4: 1
    order--5: 1
    order--7: 1
    order-10: 1
    order-11: 1
    order-12: 1
    order-13: 1
    order-14: 1
  Total free pages: 31929

--- 1. Basic alloc/free test ---
  After allocating 1, 2, 4 pages:
  [Buddy Status] nr_free per order:
    order--1: 1
    order--4: 1
    order--5: 1
    order--7: 1
    order-10: 1
    order-11: 1
    order-12: 1
    order-13: 1
    order-14: 1
  Total free pages: 31922
  After freeing all pages:
  [Buddy Status] nr_free per order:
    order--0: 1
    order--3: 1
    order--4: 1
    order--5: 1
    order--7: 1
    order-10: 1
    order-11: 1
    order-12: 1
    order-13: 1
    order-14: 1
  Total free pages: 31929
buddy_system_check(): basic alloc/free pass.

--- 2. Edge case and invalid request test ---
  After allocating max_alloc_size (8192 pages):
  [Buddy Status] nr_free per order:
    order--0: 1
    order--3: 1
    order--4: 1
    order--5: 1
    order--7: 1
    order-10: 1
    order-11: 1
    order-12: 1
    order-14: 1
  Total free pages: 23737
  After freeing max_alloc_size:
  [Buddy Status] nr_free per order:
    order--0: 1
    order--3: 1
    order--4: 1
    order--5: 1
    order--7: 1
    order-10: 1
    order-11: 1
    order-12: 1
    order-13: 1
    order-14: 1
  Total free pages: 31929
buddy_system_check(): edge case and invalid request pass.

--- 3. Split and merge test ---
  a. Clearing smaller blocks to ensure a clean test environment...
     After clearing temp blocks:
  [Buddy Status] nr_free per order:
    order--1: 1
    order--4: 1
    order--5: 1
    order--7: 1
    order-10: 1
    order-11: 1
    order-12: 1
    order-13: 1
    order-14: 1
  Total free pages: 31922
  b. Preparing a clean 8-page block...
     Allocated p1(8): pa=0x80350000, page_idx=848
  [Buddy Status] nr_free per order:
    order--1: 1
    order--3: 1
    order--5: 1
    order--7: 1
    order-10: 1
    order-11: 1
    order-12: 1
    order-13: 1
    order-14: 1
  Total free pages: 31914
     Freed p1(8). Current free pages: 31922
  [Buddy Status] nr_free per order:
    order--1: 1
    order--4: 1
    order--5: 1
    order--7: 1
    order-10: 1
    order-11: 1
    order-12: 1
    order-13: 1
    order-14: 1
  Total free pages: 31922
  c. Triggering split...
     Allocated p_left(4): pa=0x80350000, page_idx=848
  [Buddy Status] nr_free per order:
    order--1: 1
    order--2: 1
    order--3: 1
    order--5: 1
    order--7: 1
    order-10: 1
    order-11: 1
    order-12: 1
    order-13: 1
    order-14: 1
  Total free pages: 31918
     Allocated p_right(4): pa=0x80354000, page_idx=852
  [Buddy Status] nr_free per order:
    order--1: 1
    order--3: 1
    order--5: 1
    order--7: 1
    order-10: 1
    order-11: 1
    order-12: 1
    order-13: 1
    order-14: 1
  Total free pages: 31914
  d. Triggering merge...
     Freed p_left(4):
  [Buddy Status] nr_free per order:
    order--1: 1
    order--2: 1
    order--3: 1
    order--5: 1
    order--7: 1
    order-10: 1
    order-11: 1
    order-12: 1
    order-13: 1
    order-14: 1
  Total free pages: 31918
     Freed p_right(4), should trigger merge:
  [Buddy Status] nr_free per order:
    order--1: 1
    order--4: 1
    order--5: 1
    order--7: 1
    order-10: 1
    order-11: 1
    order-12: 1
    order-13: 1
    order-14: 1
  Total free pages: 31922
  e. Verifying merge result...
     Allocated merged block p_merged(8):
  [Buddy Status] nr_free per order:
    order--1: 1
    order--3: 1
    order--5: 1
    order--7: 1
    order-10: 1
    order-11: 1
    order-12: 1
    order-13: 1
    order-14: 1
  Total free pages: 31914
     Freed merged block:
  [Buddy Status] nr_free per order:
    order--1: 1
    order--4: 1
    order--5: 1
    order--7: 1
    order-10: 1
    order-11: 1
    order-12: 1
    order-13: 1
    order-14: 1
  Total free pages: 31922
  f. Restoring smaller blocks...
     Final state after all tests:
  [Buddy Status] nr_free per order:
    order--0: 1
    order--3: 1
    order--4: 1
    order--5: 1
    order--7: 1
    order-10: 1
    order-11: 1
    order-12: 1
    order-13: 1
    order-14: 1
  Total free pages: 31929
buddy_system_check(): split and merge pass.
==================================================
buddy_system_check() ALL PASSED!
==================================================
check_alloc_page() succeeded!
satp virtual address: 0xffffffffc0205000
satp physical address: 0x0000000080205000
```

## 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）

从bootloader/BIOS/OpenSBI中传入DTB/内存信息布局（E820调用）。

如果不行，可以在较低权限下将内存所有地方全都写0x55AA,能读的就是可以使用的内存（但可能误写入MMIO导致副作用？）

没有想到其他的方法。