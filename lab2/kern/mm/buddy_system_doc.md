## **伙伴系统物理内存管理器 (Buddy System PMM) 设计文档**

### 1. 概述

伙伴系统的核心思想是将所有空闲内存划分为大小为 2 的幂次方（`2^k`）的块。当需要分配内存时，它会寻找大小最接近且不小于请求大小的空闲块。如果找到的块过大，则会递归地将其对半分裂，直到得到合适大小的块，剩余的“伙伴”块则被放入相应大小的空闲链表中。当内存被释放时，系统会检查其伙伴块是否也处于空闲状态，如果是，则将它们合并成一个更大的块，并递归地向上合并。

**主要特性:**
*   **高效的块操作**：通过位运算（XOR）快速定位伙伴块，使得分裂和合并操作非常高效。
*   **减少外部碎片**：相比firstfit等算法，伙伴系统能有效地合并小块，从而减少因小块内存不连续而导致的外部碎片。
*   **内部碎片**：由于所有分配块的大小都向上取整到最近的 2 的幂次方，可能会产生一定的内部碎片。

### 2. 核心数据结构

为了实现伙伴系统，我们对核心的 `struct Page` 结构复用了现有字段：

*   `page_link` (`list_entry_t`)：用于将空闲块的首页（`head page`）串联到对应大小的空闲链表中。
*   `property` (`uint16_t`)：
    *   当一个页是**空闲块的首页**时，`property` 存储该块的大小等级，即 `order` (0 到 `MAX_ORDER`)。
    *   当一个页是**已分配块的首页**时，`property` 同样存储其 `order`，用于释放时确认块大小。
*   `flags` (`uint16_t`)：
    *   通过 `PG_property` 标志位来区分一个页是否是**空闲块的首页**。`SetPageProperty()` 和 `ClearPageProperty()` 宏用于操作此位。这使得我们可以在 O(1) 时间内判断一个页是否是空闲块的头部。

并且修改了关于`free_area_t`的逻辑。我们将`free_area_t`扩展至每个大小为2^k的空闲块对应一个free_area。

```c
#define MAX_ORDER 14 // 定义了管理的最大块大小，鉴于内存管理设置的一共只有不到128MiB，这个设置足够了

typedef struct {
    list_entry_t free_list; // 双向循环链表，链接所有该 order 的空闲块
    unsigned int nr_free;   // 该 order 的空闲块数量
} free_area_t;

static free_area_t free_area[MAX_ORDER + 1];
```


*   通过 `free_list(order)` 和 `nr_free(order)` 宏可以方便地访问特定 `order` 的链表和计数。

### 3. 算法实现

#### 3.1 `buddy_system_init_memmap()` - 初始化与自然对齐

此函数负责将 `page_init()` 传入的一大块连续的物理内存区域，正确地、符合伙伴系统规则地划分为多个初始空闲块。

**核心原则：自然对齐 (Natural Alignment)**
一个大小为 `2^k` 页的块，其起始页的索引 `page_idx` 必须是 `2^k` 的整数倍。

**实现逻辑：**
1.  将传入的所有页面都标记为非保留（`Reserved`）状态。
2.  从内存区域的起始位置开始 (`current_pos = 0`)，循环处理直到覆盖整个区域。
3.  在当前位置，从 `MAX_ORDER` 向下遍历，寻找能创建的**最大、且满足自然对齐**的块。
    *   **对齐检查**：`((current_page - pages) % block_size) == 0`
    *   **边界检查**：确保该块不会超出给定的内存区域范围。
4.  找到最合适的块后，将其首页的 `property` 设置为对应的 `order`，并加入 `free_area` 中相应 `order` 的空闲链表。
5.  更新 `current_pos`，跳过刚刚划分的块，继续处理剩余的内存区域。

这个过程确保了所有初始空闲块都满足自然对齐，为后续 `get_buddy_addr` 的正确性奠定了基础。

#### 3.2 `buddy_system_alloc_pages()` - 分配与分裂

1.  **输入验证**：检查请求的页数 `n` 是否为 2 的幂次方。当前实现选择**拒绝**非 2 的幂次方的请求，返回 `NULL`。
2.  **寻找合适的块**：计算出请求对应的 `order`，然后从该 `order` 开始向上遍历 `free_area` 数组，直到找到第一个 `nr_free > 0` 的链表。
3.  **分裂过程**：
    *   如果找到的块 `current_order` 大于请求的 `order`，则进行分裂。
    *   从链表中取出一个块，将其从 `current_order` 链表中移除。
    *   循环地将块对半分裂：`current_order` 减一，计算出伙伴块的地址，将伙伴块标记为新的 `current_order` 大小的空闲块，并加入其对应的空闲链表。
    *   重复此过程，直到块的大小等于请求的 `order`。
4.  **返回页面**：将最终得到的块的 `PG_property` 标志清除，表示它已被分配，并更新总空闲页数 `total_nr_free`。

#### 3.3 `buddy_system_free_pages()` - 释放与合并

1.  **获取块信息**：根据待释放页 `base` 的 `property` 字段获取其 `order`。
2.  **合并循环**：
    *   进入一个循环，尝试将当前块与其伙伴合并。
    *   调用 `get_buddy_addr()` 计算伙伴块的地址。
    *   **对伙伴块进行严格审查**：
        a. **有效性**：`get_buddy_addr` 内部会检查伙伴地址是否越界，如果越界则返回 `NULL`。
        b. **空闲状态**：检查伙伴页的 `PG_property` 标志位，确认其是否是空闲块的首页。
        c. **大小匹配**：检查伙伴页的 `property` 字段，确认其 `order` 是否与当前块的 `order` 相同。
    *   **执行合并**：如果所有审查都通过，说明找到了一个可以合并的伙伴。将伙伴从其空闲链表中移除，然后选择两者中地址较小的作为新合并块的首页，`order` 加一。
    *   **继续循环**：以这个新合并的、更大的块为基础，继续尝试向上合并。
    *   如果任何审查失败，则说明无法继续合并，`break` 循环。
3.  **加入链表**：将最终得到的（可能已经合并过的）块，加入其最终 `order` 对应的空闲链表。

### 4. 测试策略 (`buddy_system_check`)



1.  **初始状态打印**：
2.  **基本分配/释放测试**：分配不同大小的块，然后全部释放，验证总空闲页数是否恢复到初始值。
3.  **边界与非法请求测试**：
4.  **分裂与合并深度测试**：
    *   **创建纯净环境**：首先分配掉一些小块（如1、2、4页），以避免它们干扰后续的合并测试。
    *   **准备测试块**：分配并立即释放一个中等大小的块（如8页），确保 `free_area` 中有一个干净的、已知地址的空闲块。
    *   **测试分裂**：从这个8页块中分配两个4页块，验证地址是否正确，并观察 `free_area` 的状态变化。
    *   **测试合并**：依次释放这两个4页块，验证它们是否能正确地合并回原来的8页块，并观察 `free_area` 的状态。
    *   **恢复环境**：释放最初为创建纯净环境而分配的小块，确保最终总空闲页数与测试开始时完全一致。
