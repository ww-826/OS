## 实验四 — 进程管理

### 练习0：填写已有实验

本实验依赖实验2（物理内存管理）和实验3（虚拟内存管理）。相关代码已按照要求填入本实验中带有“LAB2”,“LAB3”注释的相应部分。

---

## 实验四 — 练习1 分配并初始化进程控制块 (alloc_proc)

### 实现思路与过程

1. 分配内存

   - 使用内核内存分配器 `kmalloc` 为 `struct proc_struct` 分配一段连续内存。

2. 初始化所有字段，保证每个字段处于确定的默认值，避免野指针或未定义行为：

   - `state`：初始化为 `PROC_UNINIT`，表示尚未完成初始化的进程结构。
   - `pid`：初始化为 -1，等待 `get_pid()` 分配真实 PID。
   - `runs`：0（尚未运行过）。
   - `kstack`：0（尚未分配内核栈）。
   - `need_resched`：0（默认不需要重新调度）。
   - `parent`：NULL（尚未设置父进程）。
   - `mm`：NULL（本实验中 VM 管理尚未建立或共享）。
   - `context`：全部清零（`memset`），以确保寄存器上下文的确定初始状态。
   - `tf`：NULL（尚未建立 trapframe）。
   - `pgdir`：设为内核启动页表基址 `boot_pgdir_pa`，保证在尚未为进程建立独立页表前不会使用不正确的页表。
   - `flags`：0（默认没有特殊标志）。
   - `name`：清零，后续通过 `set_proc_name` 设定进程名。
   - 列表成员 `list_link` 与 `hash_link`：调用 `list_init()` 初始化链表头，确保后续插入与删除安全。

3. 返回初始化后的 `proc_struct *` 给上层创建流程（例如 `do_fork` 或 `proc_init`）。

实现时的关键设计考虑：

- 绝大部分字段都使用显式的、可辨认的“安全默认值”，以便后续断言与检查（例如 `proc_init` 中对 `idleproc` 的断言）能通过。
- 将 `pgdir` 设为 `boot_pgdir_pa` 是为了在尚未为进程分配独立页表前避免出现未定义的页表访问（更稳健的选择）。

### 两个关键成员变量含义与作用

1. `struct context context`

   - 含义：用于保存内核级上下文切换所需的寄存器值（主要是 callee-saved 寄存器：`ra`, `sp`, `s0`..`s11` 等）。
   - 在本实验的作用：
     - 当内核进行线程/进程切换时，当前执行实体（进程/线程）的寄存器状态会保存在该 `context` 中。
     - `switch_to(&from->context, &to->context)` 会把 `from` 的寄存器保存到其 `context`，并从 `to->context` 恢复寄存器，从而实现 CPU 执行流从 `from` 切换到 `to`。
     - `copy_thread` 在创建新线程时会设置 `context.ra`（返回地址）和 `context.sp`（栈指针），以保证新线程第一次被调度时能进入指定的内核入口（如 `forkret`）。

2. `struct trapframe *tf`

   - 含义：指向保存发生 trap（中断/异常/系统调用）时 CPU 寄存器状态的数据结构，包含通用寄存器、程序计数器（`epc`）、状态寄存器等。
   - 在本实验的作用：
     - Trapframe 用于保存从用户态进入内核态时的完整用户寄存器上下文，以便内核在处理完中断或系统调用后可以恢复用户程序的执行状态。
     - 在创建进程（如 `do_fork` / `copy_thread`）时，会把一个临时的 trapframe 复制到 `proc->tf`，并对其进行必要修改（例如在子进程 `a0` 置 0，使 fork 在子进程中返回 0）。
     - `proc->tf` 也是 `forkret` 或者 `forkrets` 这些内核入口用于确定进程首次返回到用户态时寄存器值的依据。

总结：`context` 负责保存内核态执行的寄存器集合（内核栈与内核函数返回路径），而 `trapframe` 保存从用户态进入内核态时的寄存器快照，二者在不同场景（内核内上下文切换 vs. 用户/内核边界的 trap 保存/恢复）互补地完成进程切换与返回。

---

## 实验四 — 练习2 为新创建的内核线程分配资源 (do_fork)

### 实现思路与过程

`do_fork` 函数是创建新进程或线程的核心，其实现遵循了资源分配和状态复制的原则，并确保了完善的错误清理机制。

1. **分配 PCB 和检查限制：**
    * 首先检查当前进程数 `nr_process` 是否达到 `MAX_PROCESS` 上限。
    * 调用 `alloc_proc()` 分配并初始化 `proc_struct`。若失败，返回 `-E_NO_MEM`。
    * 设置新进程的父进程指针：`proc->parent = current;`

2. **分配内核栈：**
    * 调用 `setup_kstack(proc)` 分配一个 `KSTACKPAGE` 大小的物理内存作为新进程的内核栈。
    * 如果分配失败，通过 `goto bad_fork_cleanup_proc;` 跳转到清理逻辑，释放已分配的 `proc` 结构。

3. **复制/共享内存管理信息：**
    * 调用 `copy_mm(clone_flags, proc)` 处理地址空间。对于内核线程（设置了 `CLONE_VM` 标志），该函数通常是空操作，因为它们共享内核地址空间。
    * 如果 `copy_mm` 失败，跳转到 `bad_fork_cleanup_kstack;`，释放内核栈和 `proc` 结构。

4. **复制线程上下文：**
    * 调用 `copy_thread(proc, stack, tf)`。
    * **核心操作：** 在新内核栈顶预留空间，将父进程的 `tf` 复制到 `proc->tf`，并修改子进程的返回值 `a0` 为 0。同时，设置 `proc->context.ra` 为 `forkret`，`proc->context.sp` 指向 `proc->tf`，为新线程的首次运行做好准备。

5. **注册进程：**
    * 调用 `get_pid()` 获取一个唯一 PID，并设置 `proc->pid`。
    * 调用 `hash_proc(proc)` 和 `list_add(&proc_list, &proc->list_link)` 将新进程加入全局进程管理列表和哈希表。
    * 增加进程计数 `nr_process++`。

6. **唤醒进程并返回：**
    * 调用 `wakeup_proc(proc)`，将新进程状态设置为 `PROC_RUNNABLE`，使其可以被调度器选择。
    * 设置返回值 `ret` 为 `proc->pid`。

7. **清理机制：**
    * 使用 `goto` 语句实现多级资源释放，确保在任何分配失败后，已占用的资源（如 PCB、内核栈）都能被正确释放。

### Ucore 是否做到给每个新 fork 的线程一个唯一的 ID？

**回答：** **是**，ucore 确保了给每个新创建的进程（包括线程）一个唯一的 ID。

**分析和理由：**

1.  **`get_pid()` 函数：** `do_fork` 在创建完进程结构后，通过调用 `get_pid()` 来获取并分配进程 ID。
2.  **PID 分配机制：** `get_pid()` 函数通过一个循环递增的静态变量 `last_pid` 来尝试分配 PID。
3.  **冲突检测与避免：**
    * `get_pid()` 遍历当前的进程列表（通过 `proc_list`），检查待分配的 `last_pid` 是否已经被系统中某个存活的进程占用。
    * 如果发现冲突，它会继续递增 `last_pid` 直到找到一个未被占用的 ID。
    * 此外，它还通过 `next_safe` 变量优化了查找过程，记录下一个可能发生冲突的 PID，从而避免重复遍历整个列表。
4.  **哈希表辅助：** 新分配的 PID 通过 `hash_proc(proc)` 立即添加到 `hash_list` 中，确保未来对 PID 的查找和验证更加高效。

由于 `get_pid()` 机制保证了新分配的 PID 在当前的 `proc_list` 中是独一无二的，因此 ucore 成功地为每个新 fork 的线程（或进程）分配了一个全局唯一的 ID。

---

## 实验四 — 练习3 编写 proc_run 函数

### 实现思路与过程

`proc_run` 函数用于将指定的进程 `proc` 调度到 CPU 上运行。它涉及中断管理、地址空间切换和上下文切换三个核心步骤。

1.  **进程检查：**
    * 首先检查 `if (proc != current)`，如果目标进程已经是当前进程，则跳过切换。

2.  **禁用中断：**
    * 调用 `local_intr_save(intr_flag)`。这是为了确保在切换 `current` 指针、`satp` 寄存器和调用 `switch_to` 期间，CPU不会被中断打断，从而保证上下文切换的原子性。

3.  **更新状态：**
    * 保存旧进程指针 `struct proc_struct *prev = current;`。
    * 更新全局当前进程指针 `current = proc;`。

4.  **切换页表：**
    * 调用 `lsatp((unsigned int)proc->pgdir)`。在 RISC-V 上，这会设置 **SATP** 寄存器，使 CPU 的虚拟地址空间切换到新进程 `proc` 所对应的页表结构。

5.  **上下文切换：**
    * 调用 `switch_to(&prev->context, &proc->context)`。
    * `switch_to` 函数负责将 `prev` 进程的内核态寄存器（尤其是 callee-saved registers）保存到 `prev->context` 中，然后从 `proc->context` 中加载寄存器，实现执行流的转移。当 `switch_to` 返回时，实际上是在新进程 `proc` 的执行流中。

6.  **恢复中断：**
    * 调用 `local_intr_restore(intr_flag)`，恢复到切换前的中断状态。

### 在本实验的执行过程中，创建且运行了几个内核线程？

在 `proc_init` 启动和 `cpu_idle` 运行阶段，uCore 核心创建并运行了 **2 个** 内核线程：

1.  **`idleproc` (PID 0, Name "idle")**
    * **创建：** 在 `proc_init` 中通过 `alloc_proc` 分配并手动初始化。
    * **运行：** 它是第一个被设置的 `current` 进程，负责在没有其他可运行进程时执行 `cpu_idle` 函数，并在其中循环调用 `schedule()`。
2.  **`initproc` (PID 1, Name "init")**
    * **创建：** 在 `proc_init` 中通过 `kernel_thread(init_main, ...)` 调用 `do_fork` 创建。
    * **运行：** 它被设置为 `PROC_RUNNABLE` 状态，并最终由 `schedule()` 调度运行 `init_main` 函数。`init_main` 是 uCore 的第二个启动线程，通常负责后续的用户进程加载。

**总结：** 核心部分创建并运行了 **2 个** 内核线程 (`idleproc` 和 `initproc`)。

---

## 扩展练习 Challenge

### 1. 说明语句 `local_intr_save(intr_flag);....local_intr_restore(intr_flag);` 是如何实现开关中断的？

这对语句是实现**原子操作**和**中断状态保护**的关键。

#### 实现原理：

1.  **`local_intr_save(intr_flag)`：**
    * **关中断：** 宏展开后会读取 CPU 的状态寄存器（在 RISC-V 中是 `sstatus` 寄存器）。
    * **保存状态：** 它将 `sstatus` 寄存器中的**中断使能位**（Supervisor Interrupt Enable, **SIE** 位）的值保存到传入的布尔变量 `intr_flag` 中。如果之前中断是开的，`intr_flag` 为真；否则为假。
    * **禁用中断：** 随后，它会修改 `sstatus` 寄存器，清除 SIE 位，从而禁用当前 CPU 上的中断。
    * **作用：** 确保进入临界区（如 `proc_run` 中的上下文切换）后，代码不会被异步中断打断，保证操作的原子性。

2.  **`local_intr_restore(intr_flag)`：**
    * **恢复状态：** 宏展开后会检查 `intr_flag` 的值。
    * **开或关：**
        * 如果 `intr_flag` 为真（即进入临界区前中断是开启的），则恢复 `sstatus` 寄存器中的 SIE 位为 1，重新开启中断。
        * 如果 `intr_flag` 为假（即进入临界区前中断就是关闭的），则保持 SIE 位为 0，中断依然保持关闭。
    * **作用：** 保证临界区结束后，中断状态能够恢复到**调用者进入前的状态**。这对于可嵌套的函数调用非常重要，避免了内层函数不小心开启了外层函数想要关闭的中断。

**总结：** 这对宏通过保存并恢复 SIE 位的机制，实现了对临界区的**原子保护**，同时保证了**中断状态的透明性**和**嵌套安全性**。

### 2. 深入理解不同分页模式的工作原理（思考题）

#### A. 解释 `get_pte()` 中两段代码相似的原因

`get_pte()` 函数（位于 `kern/mm/pmm.c`，假定实现了多级页表机制）中查找页表项的代码通常具有相似的结构，这是因为 RISC-V 的 **Sv32, Sv39, Sv48** 等分页模式本质上都基于相同的 **多级页表** 架构。

**相似性原因：**

1.  **多级页表结构统一：**
    * 无论 Sv32 (2级), Sv39 (3级), 还是 Sv48 (4级)，页表都是一个**树形结构**。
    * 每一级页表都存储了指向下一级页表或最终物理页框的**页表项 (PTE)**。
    * 每一级查找的逻辑都是：**获取当前页表基址 $\rightarrow$ 从虚拟地址中提取索引 $\rightarrow$ 计算 PTE 地址 $\rightarrow$ 读取 PTE $\rightarrow$ 检查有效性 $\rightarrow$ 获取下一级页表基址。**

2.  **代码复用逻辑：**
    * `get_pte()` 函数中的两个相似代码段可能对应于**连续的两级页表查找**。
    * 例如，在 Sv39 模式下，查找 PTE 需要遍历 PGD (页全局目录)、PUD (页上级目录)、PMD (页中级目录) 和 PTE 本身。每次查找下一级目录的逻辑几乎是相同的，只是使用的虚拟地址索引位和页表级别不同。

3.  **抽象与宏定义：** 在实际的 ucore 实现中，这两段代码可能使用了相似的宏或内联函数来抽象**提取索引**和**计算 PTE 地址**的细节，进一步增强了它们在视觉和逻辑上的相似性。

#### B. 页表项查找和分配合并在一个函数里的优缺点

`get_pte()` 将页表项查找和页表项分配合并在一个函数里，这种写法各有优缺点：

| 方面 | 优点（合并） | 缺点（合并） |
| :--- | :--- | :--- |
| **简化调用** | **易用性高：** 上层调用者（如 `vma_map`）只需调用一次函数，无需关心页表是否存在或是否需要创建。 | **职责不清：** 违反了“单一职责原则”，一个函数完成了查找（查询）和分配（修改）两个逻辑上独立的任务。 |
| **逻辑内聚** | **原子操作：** 可以更容易地在函数内部保证查找和分配之间的原子性，避免在多核环境下或中断处理中出现竞争条件。 | **复用性差：** 如果只需要纯粹的页表项查找（例如，只读操作或检查是否存在），也必须携带分配逻辑，使代码难以复用。 |
| **错误处理** | **集中处理：** 错误处理（如内存不足）可以集中在分配点，结构紧凑。 | **开销：** 如果不需要分配，额外的逻辑判断（`if (!pte && create)`）仍然存在，可能引入不必要的开销。 |

**有没有必要把两个功能拆开？**

**建议：** **有必要拆开。**

将功能拆分为两个函数（例如 `find_pte(addr)` 和 `ensure_pte(addr)` 或 `alloc_pte(addr)`）：

1.  **提高代码清晰度和可维护性：** 每个函数只做一件事，更符合软件工程原则。
2.  **提高复用性：** 允许其他模块调用纯粹的查找函数（`find_pte`）来进行只读检查，而不需要引入分配的副作用和权限检查。
3.  **更精细的控制：** 使得上层虚拟内存管理代码可以根据需要，先查找，再决定是否分配，从而更好地控制内存分配策略。

在性能敏感的内核中，通常会将核心功能拆分，以实现最优的控制和最高的效率。