# 实验1报告

## 实验中涉及的知识点

### 1

在OS原理中，操作系统的作用是连接硬件层和用户层。本实验所涉及这一机制的硬件实现是RISC-V USM特权级架构。

固件（如OpenSBI）运行于最高特权的机器态（M-mode, **编码11**），直接管理与操控硬件，并为操作系统内核提供初始化和运行时服务；

操作系统内核则运行在监管者态（S-mode, **编码01**），它依托M态固件提供的服务，负责管理整个系统的内存、进程等核心资源，并向上构建服务接口；

用户应用程序运行在最低权限的用户态（U-mode, **编码00**），其访问硬件的所有请求都必须通过系统调用接口，经由S-mode内核审核与代为执行。

本实验中的操作系统内核运行在S-mode 。它向下调用M-mode 的OpenSBI固件的接口以完成硬件初始化（如设置时钟中断），向上为U-mode 的应用程序提供系统调用服务（虽然后者本实验未体现）。

### 2.内存分布:

​	1.内存整体分布情况

| 内存地址范围                | 大小  | 区域名称              | 描述                                    |
| --------------------------- | ----- | --------------------- | --------------------------------------- |
| **0x00001000 - 0x0000FFFF** | ~60KB | **QEMU启动区域**      | QEMU固件启动代码，0x1000为CPU复位入口点 |
| **0x00010000 - 0x0001FFFF** | 64KB  | **OpenSBI固件区域**   | M模式固件，提供SBI服务，完成硬件初始化  |
| **0x80000000 - 0x800FFFFF** | 1MB   | **设备内存映射区域**  | UART、CLINT、PLIC等外设寄存器映射       |
| **0x80200000 - **           | ?     | **ucore内核加载区域** | 内核代码、数据段，kern_entry入口点      |

其中堆栈地址为0x80201000(bootstack)~0x80203000(bootstacktop),共0x2000 字节 (8KB)

本实验中bss为空，edata=end=0x80203008

```nku
(gdb) i addr bootstack
Symbol "bootstack" is at 0x80201000 in a file compiled without debugging.

(gdb) i addr bootstacktop
Symbol "bootstacktop" is at 0x80203000 in a file compiled without debugging.

(gdb) i r sp
sp             0x80203000       0x80203000 <SBI_CONSOLE_PUTCHAR>
```



​	2.ucore内核的内存分布情况如kernel.ld所示：

```ld
OUTPUT_ARCH(riscv)
ENTRY(kern_entry) /* 从kern_entry进入*/
BASE_ADDRESS = 0x80200000;  /* 内核加载基地址 */

SECTIONS
{
    . = BASE_ADDRESS;  /* 从基地址开始布局 */
    
    .text : {
        *(.text.kern_entry)  /* 内核入口代码放在最前面 */
        *(.text .stub .text.* .gnu.linkonce.t.*)
    }

    PROVIDE(etext = .); /* 定义'etext'符号指向文本段结束 */

    .rodata : { 
        *(.rodata .rodata.* .gnu.linkonce.r.*) 
    }

    . = ALIGN(0x1000);  /* 按2^12=4K页对齐 */

    .data : { 
        *(.data .data.*) 
    }
    .sdata : { 
        *(.sdata .sdata.*) 
    }  /* 小数据段 */

    PROVIDE(edata = .); /* 定义'edata'符号指向数据段结束 */

    .bss : { 
        *(.bss .bss.* .sbss*) 
    }  /* 未初始化数据段放到了最后，这是为什么呢 */

    PROVIDE(end = .); /* 定义'end'符号指向BSS段结束 */

    /DISCARD/ : {
        *(.eh_frame .note.GNU-stack)
    }
}
```

具体的地址

```UKN
(gdb) info files
Symbols from "/root/lab1/bin/kernel".
Remote target using gdb-specific protocol:
        `/root/lab1/bin/kernel', file type elf64-littleriscv.
        Entry point: 0x80200000
        0x0000000080200000 - 0x00000000802004a2 is .text
        0x00000000802004a8 - 0x0000000080200718 is .rodata
        0x0000000080201000 - 0x0000000080203000 is .data
        0x0000000080203000 - 0x0000000080203008 is .sdata
        While running this, GDB does not access memory from...
```

其中sdata存储的是小数据，如已初始化的全局变量

```KNU
(gdb) x/2xw 0x0000000080203000
0x80203000 <SBI_CONSOLE_PUTCHAR>:       0x00000001      0x00000000/*其实只有一个uint64_t的非const变量SBI_CONSOLE_PUTCHAR*/
```



### 3.对SBI的调用封装


RISC-V架构通过特权级隔离和ecall指令实现系统服务调用：

```C
uint64_t sbi_call(uint64_t sbi_type, uint64_t arg0, uint64_t arg1, uint64_t arg2) {
    uint64_t ret_val;
    __asm__ volatile (
        "mv x17, %[sbi_type]\n"  // 功能号 -> x17(a7)
        "mv x10, %[arg0]\n"      // 参数0 -> x10(a0)  
        "mv x11, %[arg1]\n"      // 参数1 -> x11(a1)
        "mv x12, %[arg2]\n"      // 参数2 -> x12(a2)
        "ecall\n"                // 陷入M模式
        "mv %[ret_val], x10"     // 返回值 -> ret_val
        : [ret_val] "=r" (ret_val)
        : [sbi_type] "r" (sbi_type), [arg0] "r" (arg0), 
          [arg1] "r" (arg1), [arg2] "r" (arg2)
        : "memory"
    );
    return ret_val;
}
```



其中putchar的调用实现如下

```C
void sbi_console_putchar(unsigned char ch) {
    sbi_call(SBI_CONSOLE_PUTCHAR, ch, 0, 0);
}
```

## OS 原理中重要但在实验中没有对应上的知识点

### 1. 进程管理与调度机制
- 缺少进程控制块的数据结构实现  
- 未实现任何进程调度算法  
- 缺乏进程间上下文切换的具体机制  

### 2. 虚拟内存管理
- 没有实现页表管理地址转换  
- 缺少页面置换算法的具体实现  
- 内存保护机制尚未建立  

### 3. 文件系统
- 文件抽象和文件描述符  
- 磁盘调度算法  
- 目录结构和权限管理  

### 4. 网络协议栈
- 网络协议实现  
- 套接字接口  
- 网络设备驱动  

### 5. 安全机制
- 用户权限管理  
- 访问控制列表  
- 安全隔离机制  

### 6. 设备管理
- 设备驱动程序框架  
- 中断处理机制  
- I/O 调度和管理  

### 7. 并发和同步
- 多线程支持  
- 锁机制和同步原语  
- 死锁处理机制  

---

## 练习1：理解内核启动中的程序入口操作

### 指令 `la sp, bootstacktop`
**操作**：  
`la sp, bootstacktop` 将 `bootstacktop` 的地址加载到栈指针寄存器 `sp` 中。  

**目的**：  
- 为内核执行准备栈空间，这是函数调用的基础设施  
- 按照 RISC-V 架构规范设置栈的生长方向  
- 为后续 C 语言函数的执行创建必要的运行环境  
- 确保内核在调用函数时有合适的空间存储参数和返回地址  

---

### 指令 `tail kern_init` 的操作和目的

**操作**：  
`tail` 是尾调用指令，直接跳转到 `kern_init` 函数执行。  

**目的**：  
- 完成从底层汇编代码到高级 C 语言代码的过渡  
- 进入内核的主要初始化阶段，开始执行实际功能  
- 优化执行效率，避免不必要的返回地址保存  
- 启动内核的核心逻辑，包括内存初始化和系统输出

## 练习2：使用 GDB 验证启动流程

为了熟悉使用 QEMU 和 GDB 的调试方法，我们使用 GDB 跟踪 QEMU 模拟的 RISV-V 从加电开始，直到执行内核第一条指令的整个过程。

### 调试过程记录及观察结果

按照指导书的提示，我们启动 QEMU 并开启 GDB 远程调试，双开终端分别进行 `make debug` 和 `make gdb` 操作。

```bash
user@thinkbook:/mnt/e/mytable/labcode/lab1$ lsof -i :1234  │user@thinkbook:/mnt/e/mytable/labcode/lab1$ make gdb
COMMAND     PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME │riscv64-unknown-elf-gdb \
qemu-syst 12646 user    9u  IPv4 170416      0t0  TCP *:123│    -ex 'file bin/kernel' \
4 (LISTEN)                                                 │    -ex 'set arch riscv:rv64' \
qemu-syst 12646 user   10u  IPv6 170417      0t0  TCP *:123│    -ex 'target remote localhost:1234'
4 (LISTEN)                                                 │GNU gdb (SiFive GDB 8.3.0-2019.08.0) 8.3
qemu-syst 12646 user   11u  IPv4 182922      0t0  TCP local│Copyright (C) 2019 Free Software Foundation, Inc.
host:1234->localhost:47994 (ESTABLISHED)                   │License GPLv3+: GNU GPL version 3 or later <http://gnu.org
riscv64-u 12856 user    9u  IPv4 191927      0t0  TCP local│/licenses/gpl.html>
host:47994->localhost:1234 (ESTABLISHED)                   │This is free software: you are free to change and redistri
user@thinkbook:/mnt/e/mytable/labcode/lab1$ kill -9 12646  │bute it.
user@thinkbook:/mnt/e/mytable/labcode/lab1$ kill -9 12856  │There is NO WARRANTY, to the extent permitted by law.
user@thinkbook:/mnt/e/mytable/labcode/lab1$ make debug     │Type "show copying" and "show warranty" for details.
                                                           │This GDB was configured as "--host=x86_64-linux-gnu --targ
                                                           │et=riscv64-unknown-elf".
                                                           │Type "show configuration" for configuration details.
                                                           │For bug reporting instructions, please see:
                                                           │<https://github.com/sifive/freedom-tools/issues>.
                                                           │Find the GDB manual and other documentation resources onli
                                                           │ne at:
                                                           │    <http://www.gnu.org/software/gdb/documentation/>.
                                                           │
                                                           │For help, type "help".
                                                           │Type "apropos word" to search for commands related to "wor
                                                           │d".
                                                           │Reading symbols from bin/kernel...
                                                           │The target architecture is assumed to be riscv:rv64
                                                           │Remote debugging using localhost:1234
                                                           │0x0000000000001000 in ?? ()
                                                           │(gdb) 
                                                        
```
这里告诉我们“现在程序停在了地址为 `0x1000` 的地方”，也就是说， RISC-V 硬件加电后最初执行的几条指令位于此。

随后我们对 kern_entry 函数下了断点，然后执行`continue`操作。

![alt text](image.png)

如图，程序现在成功运行到断点处并停止。

接下来我们使用`i r`指令观察了寄存器的值，然后使用`si`观察指令 的执行：

```bash
(gdb) si
qemu-syst 12646 user   11u  IPv4 182922      0t0  TCP local│0x0000000080200004 in kern_entry ()
host:1234->localhost:47994 (ESTABLISHED)                   │    at kern/init/entry.S:7
riscv64-u 12856 user    9u  IPv4 191927      0t0  TCP local│7           la sp, bootstacktop
host:47994->localhost:1234 (ESTABLISHED)                   │(gdb) si
user@thinkbook:/mnt/e/mytable/labcode/lab1$ kill -9 12646  │9           tail kern_init
user@thinkbook:/mnt/e/mytable/labcode/lab1$ kill -9 12856  │(gdb) si
user@thinkbook:/mnt/e/mytable/labcode/lab1$ make debug     │kern_init () at kern/init/init.c:8
                                                           │8           memset(edata, 0, end - edata);
OpenSBI v0.4 (Jul  2 2019 11:53:53)                        │(gdb) si
   ____                    _____ ____ _____                │0x000000008020000e      8           memset(edata, 0, end -
  / __ \                  / ____|  _ \_   _|               │ edata);
 | |  | |_ __   ___ _ __ | (___ | |_) || |                 │(gdb) si
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ < | |                 │0x0000000080200012      8           memset(edata, 0, end -
 | |__| | |_) |  __/ | | |____) | |_) || |_                │ edata);
  \____/| .__/ \___|_| |_|_____/|____/_____|               │(gdb) si
        | |                                                │0x0000000080200016      8           memset(edata, 0, end -
        |_|                                                │ edata);
                                                           │(gdb) si
Platform Name          : QEMU Virt Machine                 │0x000000008020001a      8           memset(edata, 0, end -
Platform HART Features : RV64ACDFIMSU                      │ edata);
Platform Max HARTs     : 8                                 │(gdb) si
Current Hart           : 0                                 │0x000000008020001c      8           memset(edata, 0, end -
Firmware Base          : 0x80000000                        │ edata);
Firmware Size          : 112 KB                            │(gdb) si
Runtime SBI Version    : 0.1                               │0x000000008020001e      8           memset(edata, 0, end -
                                                           │ edata);
PMP0: 0x0000000080000000-0x000000008001ffff (A)            │(gdb) si
PMP1: 0x0000000000000000-0xffffffffffffffff (A,R,W,X)      │0x0000000080200020      8           memset(edata, 0, end -
                                                           │ edata);
                                                           │(gdb) si
                                                           │0x0000000080200022      8           memset(edata, 0, end -
                                                           │ edata);
                                                           │(gdb) si
                                                           │memset (s=0x80203008, c=c@entry=0 '\000', n=0)
                                                           │    at libs/string.c:275
                                                           │275         while (n -- > 0) {
```

我们看到指令从我们打的断点处继续运行，首先 GDB 执行 kern_entry 的第一条汇编指令（这里显示的是第二条，PC 在 0x80200004 处）`la sp, bootstacktop`，是把栈指针 sp 初始化到内核的 boot 栈顶，为接下来执行 C 代码做准备。

接下来执行的指令是下一条执行的是 `tail kern_init`。`tail` 是 RISC-V 的伪指令，本质是跳转到 kern_init 函数，不会再返回到 kern_entry，相当于“无返回的函数调用”，用于从汇编启动代码进入 C 语言的内核初始化函数。

接下来跳转到了 C 语言函数 `kern_init()`，这里是内核真正的初始化阶段。
这里我们所看到的过程是在将内核 BSS 段（即未初始化的全局变量区域）清零；这是大多数内核启动时的标准步骤，保证未初始化的全局变量都为 0。我们跟踪到了它进入`while`循环的第一行处，这是在准备一字节一字节地把指定内存区域清零。

### 问题回答

RISC-V 硬件加电后最初执行的几条指令位于 **物理地址 `0x1000`**。这些指令主要完成 **固件初始化、基本硬件环境配置、内核加载和跳转** 等工作，最终把控制权交给内核入口 `0x80200000`。