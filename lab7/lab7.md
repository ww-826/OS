# 实验报告：Lab 7 同步互斥

## 练习0：填写已有实验

本实验依赖于实验2/3/4/5/6。在 `proc.c`、`trap.c`、`default_sched.c` 等文件中，我们已经将之前实验的代码迁移过来。
需要注意的是，为了支持 Lab 7 的同步互斥功能，我们在 `proc_struct` 中初始化了 Lab 7 新增的成员变量（如果有的话，实际上 Lab 7 主要依赖 `wait_state` 和 `wait_queue`，这些在 Lab 6 中已经存在或在 Lab 7 的 `sem.c` 中动态管理）。

## 练习1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题

### 1. 内核级信号量的设计描述与执行流程

**设计描述**:
内核级信号量 `semaphore_t` 定义在 `kern/sync/sem.h` 中，包含两个主要成员：
*   `value`: 整型变量，表示信号量的计数值。如果大于 0，表示可用资源的数量；如果小于等于 0，表示等待该资源的进程数量（或者仅仅表示资源不可用，具体取决于实现，ucore 中 `value` 仅表示资源数，等待队列单独维护）。
*   `wait_queue`: 等待队列，用于挂起因无法获取资源而阻塞的进程。

**执行流程**:
*   **`sem_init`**: 初始化信号量，设置 `value` 和初始化 `wait_queue`。
*   **`down` (P操作)**:
    1.  关中断（保证原子性）。
    2.  如果 `value > 0`，则 `value--`，开中断，返回（获取资源成功）。
    3.  如果 `value <= 0`，将当前进程加入 `wait_queue`，设置状态为 `PROC_SLEEPING`（通过 `wait_current_set`），调用 `schedule()` 进行调度（当前进程挂起）。
    4.  当进程被唤醒后，从 `wait_queue` 移除，开中断。
*   **`up` (V操作)**:
    1.  关中断。
    2.  如果 `wait_queue` 为空，则 `value++`（释放资源）。
    3.  如果 `wait_queue` 不为空，从队列中唤醒一个进程（将其状态设为 `PROC_RUNNABLE`，加入运行队列）。
    4.  开中断。

### 2. 哲学家就餐问题无死锁证明

在 `check_sync.c` 中实现的哲学家就餐问题使用了以下策略：
*   `mutex`: 一个互斥信号量，用于保护对哲学家状态数组 `state_sema` 的访问和测试操作。
*   `s[N]`: 每个哲学家一个信号量，用于阻塞和唤醒。
*   **关键逻辑**:
    ```c
    void phi_take_forks_sema(int i) {
        down(&mutex);          // 进入临界区
        state_sema[i]=HUNGRY;  // 声明饥饿
        phi_test_sema(i);      // 尝试拿两把叉子
        up(&mutex);            // 离开临界区
        down(&s[i]);           // 如果没拿到（test中没up），这里阻塞
    }
    ```
    `phi_test_sema(i)` 只有在左右邻居都不在吃饭时，才将自己设为 `EATING` 并 `up(&s[i])`。

**为什么不会死锁**:
死锁的四个必要条件是：互斥、占有并等待、不可抢占、循环等待。
在这个实现中，`phi_take_forks_sema` 是原子性的（通过 `mutex` 保护）。哲学家只有在**同时**拿到两把叉子（左右都不吃）时，才会开始吃饭。如果拿不到，他不会占有任何一把叉子，而是直接阻塞在 `s[i]` 上。
因此，破坏了“占有并等待”条件：哲学家要么拿着两把叉子吃，要么一把都不拿在等待。不可能出现每个人都拿着左边的叉子等右边叉子的情况，所以不会死锁。

### 3. 用户态信号量设计方案

**设计方案**:
用户态进程不能直接访问内核数据结构（如 `wait_queue`），也不能直接关中断。因此，用户态信号量需要通过系统调用来实现。
*   **数据结构**: 在内核中维护信号量数组或哈希表，通过 ID 或名称（如文件描述符）供用户态引用。
*   **系统调用**:
    *   `sys_sem_init(value)`: 创建并初始化信号量，返回句柄。
    *   `sys_sem_wait(sem_id)`: 对应 `down`。陷入内核，执行内核级 `down` 操作。如果阻塞，内核挂起该用户进程。
    *   `sys_sem_signal(sem_id)`: 对应 `up`。陷入内核，执行内核级 `up` 操作。
    *   `sys_sem_destroy(sem_id)`: 销毁信号量。

**异同**:
*   **相同点**: 核心逻辑一致（计数器 + 等待队列），都用于同步互斥。
*   **不同点**:
    *   **实现位置**: 内核级直接操作内核对象；用户态需要通过系统调用陷入内核。
    *   **性能**: 用户态信号量涉及用户态/内核态切换，开销较大。
    *   **原子性保证**: 内核级通过关中断或自旋锁；用户态通过系统调用（内核代为保证）。

## 练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题

### 1. 内核级条件变量的设计描述与执行流程

**设计描述**:
条件变量 `condvar_t` 必须配合管程（Monitor）使用。管程由一个互斥锁 `mutex` 和若干条件变量组成。
*   `sem`: 用于让调用 `cond_wait` 的线程阻塞。
*   `count`: 记录等待在该条件变量上的线程数。
*   `owner`: 指向所属的管程 `monitor_t`。

管程 `monitor_t` 包含：
*   `mutex`: 互斥锁，保证管程过程的互斥访问。
*   `next`: 信号量，用于实现 Hoare 语义（Signal 操作后，发出信号的进程挂起，让被唤醒的进程立即执行）。
*   `next_count`: 等待在 `next` 上的进程数。

**执行流程**:
*   **`cond_wait(cv)`**:
    1.  `cv.count++`。
    2.  如果 `monitor.next_count > 0`（说明有发出 signal 的进程在等待），则 `up(monitor.next)` 唤醒它；否则 `up(monitor.mutex)` 开放管程入口。
    3.  `down(cv.sem)`：当前进程阻塞在条件变量上。
    4.  `cv.count--`。
*   **`cond_signal(cv)`**:
    1.  如果 `cv.count > 0`（有进程在等待）：
        1.  `monitor.next_count++`。
        2.  `up(cv.sem)`：唤醒等待在条件变量上的进程。
        3.  `down(monitor.next)`：自己阻塞在 `next` 上（Hoare 语义，移交控制权）。
        4.  `monitor.next_count--`。

### 2. 用户态条件变量设计方案

**设计方案**:
类似于用户态信号量，需要系统调用支持。
*   **数据结构**: 内核维护管程和条件变量对象。
*   **系统调用**:
    *   `sys_monitor_init`, `sys_cond_init`
    *   `sys_monitor_enter(mon_id)`: `down(mutex)`
    *   `sys_monitor_exit(mon_id)`: `up(mutex)` (需处理 `next` 逻辑)
    *   `sys_cond_wait(cond_id, mon_id)`: 执行内核级 `cond_wait`。
    *   `sys_cond_signal(cond_id)`: 执行内核级 `cond_signal`。

**异同**:
*   **相同点**: 语义一致（Wait/Signal）。
*   **不同点**: 用户态需要频繁的系统调用来完成管程的进入、退出、Wait 和 Signal，开销显著。通常用户态库（如 Pthreads）会在用户空间实现一部分逻辑（如自旋锁），只有在真正需要挂起时才调用内核（futex 机制）。

### 3. 能否不用信号量实现条件变量？

**回答**: 可以。
**理由**: 信号量本身也是一种同步原语，可以用更底层的原语（如自旋锁 + 线程挂起/唤醒原语）来实现条件变量。
**设计说明**:
*   使用一个自旋锁 `lock` 保护条件变量的内部数据（如等待队列）。
*   `wait(cv, mutex)`:
    1.  获取 `cv.lock`。
    2.  将自己加入 `cv.wait_queue`。
    3.  释放 `mutex`（原子性地）。
    4.  释放 `cv.lock` 并挂起自己（Context Switch）。
    5.  被唤醒后，重新获取 `mutex`。
*   `signal(cv)`:
    1.  获取 `cv.lock`。
    2.  从 `cv.wait_queue` 取出一个线程。
    3.  将其唤醒（放入运行队列）。
    4.  释放 `cv.lock`。

这种实现方式直接操作线程调度，比基于信号量的实现更底层，通常效率更高（避免了信号量那一层的额外开销）。

## 扩展练习 Challenge 1: 死锁探测

(此处简述思路)
可以在申请资源（如 `down` 操作）时，记录资源分配图（Resource Allocation Graph）。
*   每个进程是一个节点。
*   每个资源（信号量）是一个节点。
*   进程申请资源：画一条从进程到资源的边。
*   资源分配给进程：画一条从资源到进程的边。
*   **探测**: 定期或在申请资源阻塞时，遍历图寻找环路。如果存在环路，则检测到死锁。
*   **处理**: 打印信息，或者强制终止环路中的某个进程。

## 扩展练习 Challenge 2: RCU 机制

(此处简述思路)
RCU (Read-Copy-Update) 适用于读多写少的场景。
*   **读侧**: 不需要锁，直接读取数据。需要禁止抢占（在临界区内）。
*   **写侧**:
    1.  复制一份数据。
    2.  修改副本。
    3.  原子地用新指针替换旧指针（Publish）。
    4.  **Synchronize**: 等待所有在旧数据上的读者离开临界区（Grace Period）。
    5.  释放旧数据。
*   **ucore 实现**:
    *   利用 `disable_preempt()` 和 `enable_preempt()` 标记读临界区。
    *   写者通过检测所有 CPU（或线程）发生过一次上下文切换来判断 Grace Period 结束。

## 知识点总结

*   **同步互斥机制**: 信号量、管程、条件变量是解决并发问题的核心工具。
*   **Hoare vs Mesa 管程**: ucore 实现的是 Hoare 管程（Signal 后立即切换），而大多数现代 OS（如 Linux, Java）使用 Mesa 管程（Signal 只是放入就绪队列，发出者继续运行）。Hoare 语义实时性强但上下文切换多；Mesa 语义效率高但需要 `while` 循环检查条件。
*   **死锁**: 理解死锁产生的四个必要条件是避免和处理死锁的基础。

**OS 原理中重要但实验未涉及的点**:
*   **自旋锁 (Spinlock)**: 在多核系统中非常重要，用于短时间的互斥。
*   **读写锁 (RWLock)**: 优化读多写少场景的并发性。
*   **Futex**: Linux 中的快速用户态互斥锁，结合了用户态原子操作和内核态挂起，性能极高。
